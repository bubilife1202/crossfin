#!/usr/bin/env node
import { readFile, writeFile } from 'node:fs/promises'
import { resolve, dirname } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const rootDir = resolve(__dirname, '../../..')
const catalogPath = resolve(rootDir, 'catalog/crossfin-catalog.json')
const apiIndexPath = resolve(rootDir, 'apps/api/src/index.ts')
const webCatalogGeneratedPath = resolve(rootDir, 'apps/web/src/lib/catalog.generated.ts')
const webWellKnownPath = resolve(rootDir, 'apps/web/public/.well-known/crossfin.json')
const webAppPath = resolve(rootDir, 'apps/web/src/App.tsx')

function withSampleQuery(path, sampleQuery) {
  if (!sampleQuery) return path
  return `${path}?${sampleQuery}`
}

function buildPlaygroundEndpoints(catalog) {
  const free = catalog.freePlaygroundEndpoints.map((entry) => ({
    path: entry.path,
    label: `[Free] ${entry.label}`,
  }))

  const paid = catalog.paidEndpoints.map((entry) => ({
    path: withSampleQuery(entry.path, entry.sampleQuery),
    label: `[Paid] ${entry.playgroundLabel} (${entry.price})`,
  }))

  return [...free, ...paid]
}

function buildWebCatalogSource(catalog) {
  const endpoints = buildPlaygroundEndpoints(catalog)
  return `// Auto-generated by apps/api/scripts/catalog-guard.mjs. Do not edit manually.\n\nexport const CROSSFIN_API_VERSION = ${JSON.stringify(catalog.apiVersion)}\n\nexport const CROSSFIN_PLAYGROUND_ENDPOINTS: { path: string; label: string }[] = ${JSON.stringify(endpoints, null, 2)}\n`
}

function buildWellKnown(catalog) {
  return {
    name: 'CrossFin',
    version: catalog.apiVersion,
    description: 'Agent-first directory and gateway for x402 services and Korean market data.',
    urls: {
      website: 'https://crossfin.dev',
      openapi: 'https://crossfin.dev/api/openapi.json',
      guide: 'https://crossfin.dev/api/docs/guide',
      registry: 'https://crossfin.dev/api/registry',
      registrySearch: 'https://crossfin.dev/api/registry/search?q=',
      registryStats: 'https://crossfin.dev/api/registry/stats',
    },
    payment: {
      protocol: 'x402',
      network: 'eip155:8453',
      currency: 'USDC',
      note: 'Paid endpoints respond with HTTP 402 and a PAYMENT-REQUIRED header (base64 JSON).',
    },
    mcp: {
      name: 'crossfin',
      package: 'crossfin-mcp',
      run: 'npx -y crossfin-mcp',
      repo: 'https://github.com/bubilife1202/crossfin/tree/main/apps/mcp-server',
      env: {
        CROSSFIN_API_URL: 'https://crossfin.dev',
      },
      tools: catalog.mcpTools,
    },
    updatedAt: '2026-02-16T00:00:00.000Z',
  }
}

function extractPremiumMiddlewarePaths(indexSource) {
  const middlewareStart = indexSource.indexOf('const middleware = paymentMiddleware(')
  if (middlewareStart < 0) {
    throw new Error('Could not find payment middleware block in API index.ts')
  }

  const middlewareEnd = indexSource.indexOf('resourceServer,', middlewareStart)
  if (middlewareEnd < 0) {
    throw new Error('Could not find end of payment middleware block in API index.ts')
  }

  const middlewareBlock = indexSource.slice(middlewareStart, middlewareEnd)
  const paths = new Set()

  for (const match of middlewareBlock.matchAll(/'GET (\/api\/premium\/[^']+)'\s*:/g)) {
    paths.add(match[1])
  }

  return [...paths].sort()
}

function assert(condition, message) {
  if (!condition) {
    throw new Error(message)
  }
}

async function readJson(path) {
  return JSON.parse(await readFile(path, 'utf8'))
}

async function maybeWrite(path, content, writeMode) {
  let current = ''
  try {
    current = await readFile(path, 'utf8')
  } catch (err) {
    if (!err || err.code !== 'ENOENT') throw err
  }
  const normalized = content.endsWith('\n') ? content : `${content}\n`

  if (current === normalized) return false

  if (!writeMode) {
    throw new Error(`Outdated generated file: ${path}`)
  }

  await writeFile(path, normalized, 'utf8')
  return true
}

async function run() {
  const writeMode = process.argv.includes('--sync')

  const catalog = await readJson(catalogPath)
  const apiIndex = await readFile(apiIndexPath, 'utf8')
  const webApp = await readFile(webAppPath, 'utf8')

  assert(Array.isArray(catalog.paidEndpoints), 'catalog.paidEndpoints must be an array')
  assert(catalog.paidEndpoints.length > 0, 'catalog.paidEndpoints must not be empty')

  const expectedPaidPaths = catalog.paidEndpoints.map((entry) => entry.path).sort()
  const middlewarePaidPaths = extractPremiumMiddlewarePaths(apiIndex)

  assert(
    JSON.stringify(expectedPaidPaths) === JSON.stringify(middlewarePaidPaths),
    `API paid middleware paths mismatch. expected=${expectedPaidPaths.length}, actual=${middlewarePaidPaths.length}`,
  )

  assert(
    apiIndex.includes('pricing: CROSSFIN_PAID_PRICING'),
    'OpenAPI x-x402 pricing is not sourced from CROSSFIN_PAID_PRICING',
  )

  assert(
    apiIndex.includes('const crossfinSeedSpecs = CROSSFIN_PAID_ENDPOINTS.map'),
    'Registry seeds are not sourced from CROSSFIN_PAID_ENDPOINTS',
  )

  assert(
    apiIndex.includes('version: CROSSFIN_API_VERSION'),
    'API responses are not using CROSSFIN_API_VERSION',
  )

  assert(
    webApp.includes('CROSSFIN_PLAYGROUND_ENDPOINTS'),
    'Web playground is not using generated catalog endpoints',
  )

  const generatedCatalogSource = buildWebCatalogSource(catalog)
  const generatedWellKnown = `${JSON.stringify(buildWellKnown(catalog), null, 2)}\n`

  const changedGenerated = await maybeWrite(webCatalogGeneratedPath, generatedCatalogSource, writeMode)
  const changedWellKnown = await maybeWrite(webWellKnownPath, generatedWellKnown, writeMode)

  if (writeMode) {
    const updates = []
    if (changedGenerated) updates.push(webCatalogGeneratedPath)
    if (changedWellKnown) updates.push(webWellKnownPath)
    if (updates.length === 0) {
      console.log('catalog-guard: already up to date')
    } else {
      console.log(`catalog-guard: updated ${updates.join(', ')}`)
    }
  } else {
    console.log('catalog-guard: verification passed')
  }
}

run().catch((err) => {
  console.error(`catalog-guard: ${err.message}`)
  process.exit(1)
})
